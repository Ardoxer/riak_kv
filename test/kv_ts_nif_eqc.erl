%%
%%  Equivalence tests between Erlang and NIF protobuf encoder/decoders
%%
-module(kv_ts_nif_eqc).
-compile([export_all]).

%-ifdef(EQC).
-include_lib("eqc/include/eqc.hrl").
-include_lib("eunit/include/eunit.hrl").
-include_lib("riak_pb/include/riak_ts_pb.hrl").

%% ====================================================================
%% Eunit
%% ====================================================================
-define(QC_OUT(P),
        eqc:on_output(fun(Str, Args) ->
                              io:format(user, Str, Args) end, P)).

encode_tsputreq_equivalent_test_() ->
    {timeout, 15000, % do not trust the docs - timeout is in msec
      ?_assertEqual(true, quickcheck(eqc:testing_time(10, ?QC_OUT(
                                     prop_encode_tsputreq_equivalent()))))}.

decode_tsputreq_equivalent_test_() ->
    {timeout, 15000, % do not trust the docs - timeout is in msec
      ?_assertEqual(true, quickcheck(eqc:testing_time(10, ?QC_OUT(
                                     prop_decode_tsputreq_equivalent()))))}.

encode_tsqueryresp_equivalent_test_() ->
    {timeout, 15000, % do not trust the docs - timeout is in msec
      ?_assertEqual(true, quickcheck(eqc:testing_time(10, ?QC_OUT(
                                     prop_encode_tsqueryresp_equivalent()))))}.

decode_tsqueryresp_equivalent_test_() ->
    {timeout, 15000, % do not trust the docs - timeout is in msec
      ?_assertEqual(true, quickcheck(eqc:testing_time(10, ?QC_OUT(
                                     prop_decode_tsqueryresp_equivalent()))))}.

%% ====================================================================
%% Generators
%% ====================================================================

table() ->
     non_empty(binary()).

row() ->
    #tsrow{cells = list(cell())}.

column() ->
    #tscolumndescription{name = non_empty(binary()),
                         type = oneof(['VARCHAR','SINT64','DOUBLE',
                                       'TIMESTAMP','BOOLEAN'])}.

cell() -> % generate a cell where only one is present
    ?LET(
       {Index, _Varchar, _Sint64, _TS, _Bool, _Double}=Seed,
       {choose(2,6), non_empty(binary()), largeint(), nat(), bool(), real()},
       begin
           Value = element(Index, Seed),
           setelement(Index, #tscell{}, Value)
       end).

%%
%% Generate #tsputreq{} record
%%
gen_tsputreq() ->
    #tsputreq{table = table(),
              columns = oneof([undefined, list(column())]),
              rows = non_empty(list(row()))
             }.

%%
%% Generate #tsqueryresp{} record
%%
gen_tsqueryresp() ->
    #tsqueryresp{columns = oneof([undefined, list(column())]),
                 rows = list(row()),
                 done = oneof([undefined, true, false])}.


%% ====================================================================
%% riak_pb_codec.cc eqc property
%% ====================================================================

%% Generate a #tsputreq{} and compare the binary generated by the
%% Erlang code and the NIF
%%
%% Differences
%% - NIF does not permit empty columns and rows
%% - NIF does not encode column descriptions
prop_encode_tsputreq_equivalent() ->
    ?FORALL(TsPutReq,
            gen_tsputreq(),
            begin
                %% Error codes not exact, so just check for errors
                ErlBin = try
                             iolist_to_binary(riak_ts_pb:encode_tsputreq(TsPutReq))
                         catch
                             _:_ ->
                                 error
                         end,
                NifBin = try
                             MsgCode = riak_pb_messages:msg_code(tsputreq),
                             <<MsgCode:8, NifBin0/binary>> = riak_pb_codec:encode_tsputreq(TsPutReq),
                             NifBin0
                         catch
                             _:_ ->
                                 error
                         end,
                ?WHENFAIL(
                   begin
                       eqc:format("DecodedErlBin: ~w\n", [catch riak_ts_pb:decode_tsputreq(ErlBin)]),
                       eqc:format("DecodedNifBin: ~w\n", [catch riak_ts_pb:decode_tsputreq(NifBin)])
                   end,
                   equals(ErlBin, NifBin))
            end).

%% Generate an encoded #tsqueryresp{} binary and test the decoded record is the
%% same for Erlang code and the NIF
%%
%% Differences
%% - NIF flips the done bool
prop_decode_tsqueryresp_equivalent() ->
    ?FORALL(TSQueryResp,
            gen_tsqueryresp(),
            begin
                TSQueryRespBin = iolist_to_binary(riak_ts_pb:encode_tsqueryresp(TSQueryResp)),
                ErlTerm = riak_ts_pb:decode_tsqueryresp(TSQueryRespBin),
                MsgCode = riak_pb_messages:msg_code(tsqueryresp),
                NifTerm = riak_pb_codec:decode(MsgCode, TSQueryRespBin),
                case TSQueryRespBin of
                    <<>> ->   %% Erlang code decodes to atom name, NIF decodes to record
                        true; %% but still worth checking it doesn't explode
                    _ ->
                        equals(ErlTerm, NifTerm)
                end
            end).


%% ====================================================================
%% riak_kv_pb_timeseries.cc eqc property
%% ====================================================================

prop_decode_tsputreq_equivalent() ->
    ?FORALL(TSPutReq,
            gen_tsputreq(),
            begin
                TSPutReqBin = iolist_to_binary(riak_ts_pb:encode_tsputreq(TSPutReq)),
                ErlTerm = riak_ts_pb:decode_tsputreq(TSPutReqBin),
                MsgCode = riak_pb_messages:msg_code(tsputreq),
                NifTerm = riak_pb_codec:decode(MsgCode, TSPutReqBin),
                case TSPutReqBin of
                    <<>> ->   %% Erlang code decodes to atom name, NIF decodes to record
                        true; %% but still worth checking it doesn't explode
                    _ ->
                        equals(ErlTerm, NifTerm)
                end
            end).

%%
%% Differences, cannot encode empty description/rows.
%%
prop_encode_tsqueryresp_equivalent() ->
    ?FORALL(TsQueryResp,
            ?SUCHTHAT(R, gen_tsqueryresp(), R#tsqueryresp.columns /= undefined andalso
                                             R#tsqueryresp.columns /= []),
            begin
                %% Error codes not exact, so just check for errors
                ErlBin = try
                             iolist_to_binary(riak_ts_pb:encode_tsqueryresp(TsQueryResp))
                         catch
                             _:_ ->
                                 error
                         end,
                NifBin = try
                             MsgCode = riak_pb_messages:msg_code(tsqueryresp),
                             <<MsgCode:8, NifBin0/binary>> = riak_pb_codec:encode_tsqueryresp(TsQueryResp),
                             NifBin0
                         catch
                             _:_ ->
                                 error
                         end,
                ?WHENFAIL(
                   begin
                       eqc:format("DecodedErlBin: ~w\n", [catch riak_ts_pb:decode_tsqueryresp(ErlBin)]),
                       eqc:format("DecodedNifBin: ~w\n", [catch riak_ts_pb:decode_tsqueryresp(NifBin)])
                   end,
                   equals(ErlBin, NifBin))
            end).


%-endif.
