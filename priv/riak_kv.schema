%%-*- mode: erlang -*-

%% @doc How Riak will repair out-of-sync keys. Some features require
%% this to be set to 'active', including search.
%%
%% * active: out-of-sync keys will be repaired in the background
%% * passive: out-of-sync keys are only repaired on read
%% * active-debug: like active, but outputs verbose debugging
%%   information
{mapping, "anti_entropy", "riak_kv.anti_entropy", [
  {datatype, {enum, [active, passive, 'active-debug']}},
  {default, active}
]}.

{translation,
 "riak_kv.anti_entropy",
 fun(Conf) ->
    Setting = cuttlefish:conf_get("anti_entropy", Conf),
    case Setting of
      active -> {on, []};
      'active-debug' -> {on, [debug]};
      passive -> {off, []};
      _Default -> {on, []}
    end
  end
}.

%% @doc Specifies the engine used for Riak's key-value data and
%% secondary indexes (if supported).
{mapping, "storage_backend", "riak_kv.storage_backend", [
  {default, {{storage_backend}} },
  {datatype, {enum, [bitcask, leveldb, memory, multi]}}
]}.

{translation,
 "riak_kv.storage_backend",
 fun(Conf) ->
    Setting = cuttlefish:conf_get("storage_backend", Conf),
    case Setting of
      bitcask -> riak_kv_bitcask_backend;
      leveldb -> riak_kv_eleveldb_backend;
      memory -> riak_kv_memory_backend;
      multi -> riak_kv_multi_backend;
      _Default -> riak_kv_bitcask_backend
    end
 end}.

%% @doc Restrict how fast AAE can build hash trees. Building the tree
%% for a given partition requires a full scan over that partition's
%% data. Once built, trees stay built until they are expired.
%% * .number is the number of builds
%% * .per_timespan is the amount of time in which that .number of builds
%%   occurs
%%
%% Default is 1 build per hour.
{mapping, "anti_entropy.tree.build_limit.number", "riak_kv.anti_entropy_build_limit", [
  {default, 1},
  {datatype, integer},
  {level, advanced}
]}.

%% @see anti_entropy.build_limit.number
{mapping, "anti_entropy.tree.build_limit.per_timespan", "riak_kv.anti_entropy_build_limit", [
  {default, "1h"},
  {datatype, {duration, ms}},
  {level, advanced}
]}.

{translation,
 "riak_kv.anti_entropy_build_limit",
 fun(Conf) ->
    {cuttlefish:conf_get("anti_entropy.tree.build_limit.number", Conf),
     cuttlefish:conf_get("anti_entropy.tree.build_limit.per_timespan", Conf)}
 end}.

%% @doc Determine how often hash trees are expired after being built.
%% Periodically expiring a hash tree ensures the on-disk hash tree
%% data stays consistent with the actual k/v backend data. It also
%% helps Riak identify silent disk failures and bit rot. However,
%% expiration is not needed for normal AAE operation and should be
%% infrequent for performance reasons. The time is specified in
%% milliseconds.
{mapping, "anti_entropy.tree.expiry", "riak_kv.anti_entropy_expire", [
  {default, "1w"},
  {datatype, {duration, ms}},
  {level, advanced}
]}.

%% @doc Limit how many AAE exchanges or builds can happen concurrently.
{mapping, "anti_entropy.concurrency_limit", "riak_kv.anti_entropy_concurrency", [
  {default, 2},
  {datatype, integer},
  {level, advanced}
]}.

%% @doc The tick determines how often the AAE manager looks for work
%% to do (building/expiring trees, triggering exchanges, etc).
%% The default is every 15 seconds. Lowering this value will
%% speedup the rate that all replicas are synced across the cluster.
%% Increasing the value is not recommended.
{mapping, "anti_entropy.trigger_interval", "riak_kv.anti_entropy_tick", [
  {default, "15s"},
  {datatype, {duration, ms}},
  {level, advanced}
]}.

%% @doc The directory where AAE hash trees are stored.
{mapping, "anti_entropy.data_dir", "riak_kv.anti_entropy_data_dir", [
  {default, "{{platform_data_dir}}/anti_entropy"},
  {level, advanced}
]}.

%% @doc The LevelDB options used by AAE to generate the LevelDB-backed
%% on-disk hashtrees.
%% @see leveldb.write_buffer_size
{mapping, "anti_entropy.write_buffer_size", "riak_kv.anti_entropy_leveldb_opts.write_buffer_size", [
  {default, "4MB"},
  {datatype, bytesize},
  {level, advanced}
]}.

{mapping, "anti_entropy.max_open_files", "riak_kv.anti_entropy_leveldb_opts.max_open_files", [
  {default, 20},
  {datatype, integer},
  {level, advanced}
]}.

%% @doc If on, this item will disable the AAE distributed throttle
%% mechanism used by riak_kv_exchange_fsm.erl.
{mapping, "anti_entropy.throttle.kill_switch", "riak_kv.aae_throttle_kill_switch", [
  {default, off},
  {datatype, flag},
  {level, advanced}
]}.

%% @doc Override the default AAE distributed throttle mechanism
%% defaults from riak_kv.app.  For example, if a sleep time of 5
%% milliseconds is desired when the largest vnode mailbox length is
%% 40, include the setting of 'anti_entropy.throttle.limits.40 = 5'.
%%
%% Note that you must include a setting for
%% 'anti_entropy.throttle.limits.-1 = N', where N is usually 0.
{mapping, "anti_entropy.throttle.limits.$length", "riak_kv.aae_throttle_limits", [
  {datatype, {duration, ms}},
  {level, advanced}
]}.

{translation,
 "riak_kv.aae_throttle_limits",
 fun(Conf) ->
   Values = cuttlefish_variable:filter_by_prefix("anti_entropy.throttle.limits", Conf),
   [ {list_to_integer(QLen), SleepMillis} || {["anti_entropy", "throttle", "limits", QLen], SleepMillis} <- Values]
 end
}.

%% @see leveldb.bloomfilter
{mapping, "anti_entropy.bloomfilter", "riak_kv.anti_entropy_leveldb_opts.use_bloomfilter", [
  {default, on},
  {datatype, flag},
  {level, advanced}
]}.

%% @doc How many JavaScript virtual machines are available for
%% executing map functions.
{mapping, "javascript.map_pool_size", "riak_kv.map_js_vm_count", [
  {default, {{map_js_vms}} },
  {datatype, integer},
  {level, caremad}
]}.

%% @doc How many JavaScript virtual machines are available for
%% executing reduce functions.
{mapping, "javascript.reduce_pool_size", "riak_kv.reduce_js_vm_count", [
  {default, {{reduce_js_vms}} },
  {datatype, integer},
  {level, advanced}
]}.

%% @doc How many JavaScript virtual machines are available for
%% executing pre-commit hook functions.
{mapping, "javascript.hook_pool_size", "riak_kv.hook_js_vm_count", [
  {default, {{hook_js_vms}} },
  {datatype, integer},
  {level, advanced}
]}.

%% @doc The maximum amount of memory allocated to each JavaScript
%% virtual machine.
{mapping, "javascript.maximum_heap_size", "riak_kv.js_max_vm_mem", [
  {default, "8MB"},
  {datatype, bytesize},
  {level, advanced}
]}.

{translation,
 "riak_kv.js_max_vm_mem",
 fun(Conf) ->
     cuttlefish_util:ceiling(cuttlefish:conf_get("javascript.maximum_heap_size", Conf) / 1048576)
 end}.

%% @doc The maximum amount of thread stack memory to allocate
%% to each JavaScript virtual machine.
{mapping, "javascript.maximum_stack_size", "riak_kv.js_thread_stack", [
  {default, "16MB"},
  {datatype, bytesize},
  {level, advanced}
]}.

{translation,
 "riak_kv.js_thread_stack",
 fun(Conf) ->
     cuttlefish_util:ceiling(cuttlefish:conf_get("javascript.maximum_stack_size", Conf) / 1048576)
 end}.

%% @doc A directory containing Javascript source files which will be
%% loaded by Riak when it initializes Javascript VMs.
{mapping, "javascript.source_dir", "riak_kv.js_source_dir", [
  {commented, "/tmp/js_source"},
  {level, advanced}
]}.

%% We left riak_kv.add_paths out on purpose.

%% @doc This option specifies how many of each type of fsm may exist
%% concurrently.  This is for overload protection and is a new
%% mechanism that obsoletes 1.3's health checks. Note that this number
%% represents two potential processes, so erlang.process_limit in
%% vm.args should be at least 3X more. Setting this value to infinite
%% disables fsm overload protection.
{mapping, "max_concurrent_requests", "riak_kv.fsm_limit", [
  {default, 50000},
  {datatype, [integer, {atom, infinite}]},
  {level, advanced}
]}.

{translation, "riak_kv.fsm_limit",
 fun(Conf) ->
  TheLimit = cuttlefish:conf_get("max_concurrent_requests", Conf),
  case TheLimit of
      infinite -> undefined;
      Int when is_integer(Int) -> Int;
      _ ->
          throw(error)
  end
 end
}.

%% @doc If forwarding to a replica-local coordinator on PUT fails,
%% this setting will retry the operation when set to 'on'.
%%   * on = Riak 2.0 behavior (strongly recommended)
%%   * off = Riak 1.x behavior
{mapping, "retry_put_coordinator_failure", "riak_kv.retry_put_coordinator_failure", [
  {default, on},
  {datatype, flag},
  {level, advanced}
]}.

%% @doc Controls which binary representation of a riak value is stored
%% on disk.
%% * 0: Original erlang:term_to_binary format. Higher space overhead.
%% * 1: New format for more compact storage of small values.
{mapping, "object.format", "riak_kv.object_format", [
  {default, 1},
  {datatype, [{integer, 1}, {integer, 0}]}
]}.

{translation, "riak_kv.object_format",
 fun(Conf) ->
   case cuttlefish:conf_get("object.format", Conf) of
       0 -> v0;
       1 -> v1;
       _ -> throw(error)
   end
 end
}.

%% @doc md_cache_size controls how large the md cache is allowed to be
%% it defaults to 1MB, set to 0 to disable the cache.  This shouldn't
%% be neccessary on-disk based backends, but can help performance in
%% some cases (i.e. memory backend, data fits in block cache, etc).
%% note that this is the size of the ETS table, rather than the actual
%% data, to keep the size calculation simple, thus more space may be
%% used than the simple size * vnode_count calculation would imply.
{mapping, "md_cache_size", "riak_kv.vnode_md_cache_size", [
  {datatype, [{atom, off}, bytesize]},
  {default, off} %% disabled by default, to ship with this live, change to 512KB
]}.

{ translation,
  "riak_kv.vnode_md_cache_size",
  fun(Conf) ->
    case cuttlefish:conf_get("md_cache_size", Conf) of
        off -> 0;
        Size -> Size
    end
  end
}.

%%%% Memory backend section
%% @doc The maximum amount of memory consumed per vnode by the memory
%% storage backend.  Minimum: 1MB
{mapping, "memory_backend.max_memory_per_vnode", "riak_kv.memory_backend.max_memory", [
  {datatype, bytesize},
  {level, advanced}
]}.

%% @see memory_backend.max_memory
{mapping, "multi_backend.$name.memory_backend.max_memory_per_vnode", "riak_kv.multi_backend", [
  {datatype, bytesize},
  {level, advanced}
]}.

{translation,
 "riak_kv.memory_backend.max_memory",
 fun(Conf) ->
  Bytes = cuttlefish:conf_get("memory_backend.max_memory_per_vnode", Conf),
  cuttlefish_util:ceiling(Bytes / 1048576)
 end
}.

%% @doc Each value written will be written with this "time to
%% live". Once that object's time is up, it will be deleted on the
%% next read of its key. Minimum: 1s
{mapping, "memory_backend.ttl", "riak_kv.memory_backend.ttl", [
  {datatype, {duration, s}},
  {level, advanced}
]}.

%% @see memory_backend.ttl
{mapping, "multi_backend.$name.memory_backend.ttl", "riak_kv.multi_backend", [
  {datatype, {duration, s}},
  {level, advanced}
]}.

%% @doc Measures were added to Riak 1.2 to counteract cross-site
%% scripting and request-forgery attacks. Some reverse-proxies cannot
%% remove the Referer header and makes serving data directly from Riak
%% impossible. Turning secure_referer_check = off disables this
%% security check.
{mapping, "secure_referer_check", "riak_kv.secure_referer_check", [
  {datatype, flag},
  {default, on},
  {level, advanced}
]}.

%% @doc Reading or writing objects bigger than this size will write a
%% warning in the logs.
{mapping, "object.size.warning_threshold", "riak_kv.warn_object_size", [
  {datatype, bytesize},
  {default, "5MB"}
]}.

%% @doc Writing an object bigger than this will fail.
%% obligatory "too big to fail" joke.
{mapping, "object.size.maximum", "riak_kv.max_object_size", [
  {datatype, bytesize},
  {default, "50MB"}
]}.

%% @doc Writing an object with more than this number of siblings will
%% generate a warning in the logs.
{mapping, "object.siblings.warning_threshold", "riak_kv.warn_siblings", [
  {datatype, integer},
  {default, 25}
]}.

%% @doc Writing an object with more than this number of siblings will
%% fail.
{mapping, "object.siblings.maximum", "riak_kv.max_siblings", [
  {datatype, integer},
  {default, 100}
]}.

%% @doc dvv is an enhancement to riak's logical clocks that prevents
%% sibling explosion by storing an event in a value's metadata on
%% creation. Riak later later uses that event information on merging
%% conflicting writes to ensure that only genuinely concurrent values
%% remain. DVV is enabled by default. As it is a new feature, you can
%% switch it off.

{mapping, "dvv", "riak_kv.dvv_enabled", [
  {default, on},
  {datatype, flag},
  {level, advanced}
]}.

%% @doc The number of primary replicas (non-fallback) that must reply
%% to a read request.
{mapping, "buckets.default.pr", "riak_core.default_bucket_props.pr", [
  {datatype, [integer, {enum, [quorum, all]}]},
  {default, 0},
  {level, advanced}
]}.

%% @doc The number of replicas which must reply to a read request.
{mapping, "buckets.default.r", "riak_core.default_bucket_props.r", [
  {datatype, [{enum, [quorum, all]}, integer]},
  {default, quorum},
  {level, advanced}
]}.

%% @doc The number of replicas which must reply to a write request,
%% indicating that the write was received.
{mapping, "buckets.default.w", "riak_core.default_bucket_props.w", [
  {datatype, [{enum, [quorum, all]}, integer]},
  {default, quorum},
  {level, advanced}
]}.

%% @doc The number of primary replicas (non-fallback) which must reply
%% to a write request.
{mapping, "buckets.default.pw", "riak_core.default_bucket_props.pw", [
  {datatype, [integer, {enum, [quorum, all]}]},
  {default, 0},
  {level, advanced}
]}.

%% @doc The number of replicas which must reply to a write request,
%% indicating that the write was committed to durable storage.
{mapping, "buckets.default.dw", "riak_core.default_bucket_props.dw", [
  {datatype, [{enum, [quorum, all]}, integer]},
  {default, quorum},
  {level, advanced}
]}.

%% @doc The number of replicas which must reply to a delete request.
{mapping, "buckets.default.rw", "riak_core.default_bucket_props.rw", [
  {datatype, [{enum, [quorum, all]}, integer]},
  {default, quorum},
  {level, advanced}
]}.

%% @doc Whether not-founds will count toward a quorum of reads.
{mapping,
 "buckets.default.notfound_ok",
 "riak_core.default_bucket_props.notfound_ok", [
  {default, true},
  {datatype, {enum, [true, false]}},
  {level, advanced}
]}.

%% @doc Whether not-founds will invoke the "basic quorum"
%% optimization. This setting will short-circuit fetches where the
%% majority of replicas report that the key is not found. Only used
%% when notfound_ok = false.
{mapping,
 "buckets.default.basic_quorum",
 "riak_core.default_bucket_props.basic_quorum", [
 {default, false},
 {datatype, {enum, [true, false]}},
 {level, advanced}
]}.

%% @doc Whether or not siblings are allowed.  Note: See Vector Clocks
%% for a discussion of sibling resolution.
{mapping, "buckets.default.allow_mult", "riak_core.default_bucket_props.allow_mult", [
  {datatype, {enum, [true, false]}},
  {default, true},
  {level, advanced}
]}.

%% @doc Whether conflicting writes resolve via timestamp.
{mapping,
  "buckets.default.last_write_wins",
  "riak_core.default_bucket_props.last_write_wins", [
  {datatype, {enum, [true, false]}},
  {default, false},
  {level, advanced}
]}.

%% needs better docs
{mapping, "buckets.default.precommit", "riak_core.default_bucket_props.precommit", [
  {level, advanced}
]}.

{translation, "riak_core.default_bucket_props.precommit",
 fun(Conf) ->
  RawString = cuttlefish:conf_get("buckets.default.precommit", Conf, []),
  io:format("~p", [RawString]),
  io:format("~p", [lists:reverse(Conf)]),
  StringList = string:tokens(RawString, " "),
  [ begin
    case string:tokens(String, ":") of
        %% Javascript make this:  {struct, [{<<"name">>, <<"SomeJS.nonsense">>}]}
        [JavascriptFunction] ->
            {struct, [{<<"name">>, list_to_binary(JavascriptFunction)}]};
        %% Erlang make this: {struct, [{<<"mod">>, <<"module">>}, {<<"fun">>,<<"function">>}]}
        [Module, Function] ->
            {struct, [
                      {<<"mod">>, list_to_binary(Module)},
                      {<<"fun">>, list_to_binary(Function)}
                     ]};
        _ -> throw(error)
    end
  end || String <- StringList]
 end
}.

{mapping, "buckets.default.postcommit", "riak_core.default_bucket_props.postcommit", [
  {level, advanced}
]}.

%% Erlang Only
{translation, "riak_core.default_bucket_props.postcommit",
 fun(Conf) ->
   RawString = cuttlefish:conf_get("buckets.default.postcommit", Conf, []),
   StringList = string:tokens(RawString, " "),
   [ begin
     case string:tokens(String, ":") of
         [Module, Function] ->
             {struct, [
                       {<<"mod">>, list_to_binary(Module)},
                       {<<"fun">>, list_to_binary(Function)}
                      ]};
         _ -> throw(error)
     end
   end ||  String <- StringList]
 end
}.
